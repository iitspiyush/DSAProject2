{"ast":null,"code":"// // algorithms.js\n// // ====================================================\n// // This file defines: Dijkstra, Bellman–Ford, Floyd–Warshall,\n// // A* (A-Star), and Johnson’s Algorithm.\n// // All return { path, distance } for easy visualization.\n// // ====================================================\n\n// // ---------- DIJKSTRA ----------\n// export function dijkstra(graph, start, end) {\n//   const dist = {};\n//   const prev = {};\n//   const visited = new Set();\n\n//   for (let node in graph) {\n//     dist[node] = Infinity;\n//     prev[node] = null;\n//   }\n//   dist[start] = 0;\n\n//   while (visited.size < Object.keys(graph).length) {\n//     const current = Object.keys(graph)\n//       .filter((n) => !visited.has(n))\n//       .reduce((a, b) => (dist[a] < dist[b] ? a : b));\n//     if (dist[current] === Infinity) break;\n//     visited.add(current);\n\n//     for (let neighbor in graph[current]) {\n//       const newDist = dist[current] + graph[current][neighbor];\n//       if (newDist < dist[neighbor]) {\n//         dist[neighbor] = newDist;\n//         prev[neighbor] = current;\n//       }\n//     }\n//   }\n\n//   const path = [];\n//   let u = end;\n//   while (u) {\n//     path.unshift(u);\n//     u = prev[u];\n//   }\n//   return { path, distance: dist[end] };\n// }\n\n// // ---------- BELLMAN–FORD ----------\n// export function bellmanFord(graph, start, end) {\n//   const nodes = Object.keys(graph);\n//   const dist = {};\n//   const prev = {};\n//   nodes.forEach((n) => {\n//     dist[n] = Infinity;\n//     prev[n] = null;\n//   });\n//   dist[start] = 0;\n\n//   for (let i = 0; i < nodes.length - 1; i++) {\n//     for (let u of nodes) {\n//       for (let v in graph[u]) {\n//         const weight = graph[u][v];\n//         if (dist[u] + weight < dist[v]) {\n//           dist[v] = dist[u] + weight;\n//           prev[v] = u;\n//         }\n//       }\n//     }\n//   }\n\n//   const path = [];\n//   let u = end;\n//   while (u) {\n//     path.unshift(u);\n//     u = prev[u];\n//   }\n//   return { path, distance: dist[end] };\n// }\n\n// // ---------- FLOYD–WARSHALL ----------\n// export function floydWarshall(graph, start, end) {\n//   const nodes = Object.keys(graph);\n//   const dist = {};\n//   const next = {};\n\n//   for (let i of nodes) {\n//     dist[i] = {};\n//     next[i] = {};\n//     for (let j of nodes) {\n//       if (i === j) dist[i][j] = 0;\n//       else if (graph[i][j] !== undefined) dist[i][j] = graph[i][j];\n//       else dist[i][j] = Infinity;\n//       if (graph[i][j] !== undefined) next[i][j] = j;\n//       else next[i][j] = null;\n//     }\n//   }\n\n//   for (let k of nodes) {\n//     for (let i of nodes) {\n//       for (let j of nodes) {\n//         if (dist[i][k] + dist[k][j] < dist[i][j]) {\n//           dist[i][j] = dist[i][k] + dist[k][j];\n//           next[i][j] = next[i][k];\n//         }\n//       }\n//     }\n//   }\n\n//   if (next[start][end] === null) return { path: [], distance: Infinity };\n\n//   const path = [];\n//   let u = start;\n//   while (u !== end) {\n//     path.push(u);\n//     u = next[u][end];\n//   }\n//   path.push(end);\n//   return { path, distance: dist[start][end] };\n// }\n\n// // ---------- A* (A-STAR) ----------\n// export function aStar(graph, start, end, coords) {\n//   const open = new Set([start]);\n//   const cameFrom = {};\n//   const gScore = {};\n//   const fScore = {};\n\n//   for (let node in graph) {\n//     gScore[node] = Infinity;\n//     fScore[node] = Infinity;\n//   }\n//   gScore[start] = 0;\n//   fScore[start] = heuristic(start, end, coords);\n\n//   while (open.size > 0) {\n//     let current = null;\n//     let bestF = Infinity;\n//     for (let n of open) {\n//       if (fScore[n] < bestF) {\n//         bestF = fScore[n];\n//         current = n;\n//       }\n//     }\n\n//     if (current === end) {\n//       const path = [];\n//       let c = current;\n//       while (c) {\n//         path.unshift(c);\n//         c = cameFrom[c];\n//       }\n//       return { path, distance: gScore[end] };\n//     }\n\n//     open.delete(current);\n//     for (let neighbor in graph[current]) {\n//       const tentative = gScore[current] + graph[current][neighbor];\n//       if (tentative < gScore[neighbor]) {\n//         cameFrom[neighbor] = current;\n//         gScore[neighbor] = tentative;\n//         fScore[neighbor] = tentative + heuristic(neighbor, end, coords);\n//         open.add(neighbor);\n//       }\n//     }\n//   }\n\n//   return { path: [], distance: Infinity };\n// }\n\n// function heuristic(a, b, coords) {\n//   const dx = coords[a].x - coords[b].x;\n//   const dy = coords[a].y - coords[b].y;\n//   return Math.sqrt(dx * dx + dy * dy);\n// }\n\n// // ---------- JOHNSON’S ALGORITHM ----------\n// export function johnson(graph, start, end) {\n//   const nodes = Object.keys(graph);\n\n//   // Step 1: Add fake node Q\n//   const qGraph = JSON.parse(JSON.stringify(graph));\n//   qGraph.Q = {};\n//   for (let node of nodes) qGraph.Q[node] = 0;\n\n//   // Step 2: Bellman–Ford from Q to get potential h()\n//   const h = {};\n//   const bfResult = bellmanFord(qGraph, \"Q\", null);\n//   nodes.forEach((node) => {\n//     h[node] = bfResult.distance[node]; // correct potential\n//     });\n\n//   // Step 3: Reweight edges\n//   const reweighted = {};\n//   for (let u of nodes) {\n//     reweighted[u] = {};\n//     for (let v in graph[u]) {\n//       reweighted[u][v] = graph[u][v] + h[u] - h[v];\n//     }\n//   }\n\n//   // Step 4: Use Dijkstra on reweighted graph\n//   return dijkstra(reweighted, start, end);\n// }\n\n// algorithms.js\n// ====================================================\n// Corrected algorithms: Dijkstra, Bellman–Ford, Floyd–Warshall,\n// A* (A-Star), and Johnson’s Algorithm.\n// All return { path, distance } for visualization\n// ====================================================\n\n// ---------- DIJKSTRA ----------\nexport function dijkstra(graph, start, end) {\n  const dist = {};\n  const prev = {};\n  const visited = new Set();\n  for (let node in graph) {\n    dist[node] = Infinity;\n    prev[node] = null;\n  }\n  dist[start] = 0;\n  while (visited.size < Object.keys(graph).length) {\n    const current = Object.keys(graph).filter(n => !visited.has(n)).reduce((a, b) => dist[a] < dist[b] ? a : b);\n    if (dist[current] === Infinity) break;\n    visited.add(current);\n    for (let neighbor in graph[current]) {\n      const newDist = dist[current] + graph[current][neighbor];\n      if (newDist < dist[neighbor]) {\n        dist[neighbor] = newDist;\n        prev[neighbor] = current;\n      }\n    }\n  }\n  const path = [];\n  let u = end;\n  while (u) {\n    path.unshift(u);\n    u = prev[u];\n  }\n  if (dist[end] === Infinity) return {\n    path: [],\n    distance: Infinity\n  };\n  return {\n    path,\n    distance: dist[end]\n  };\n}\n\n// ---------- BELLMAN–FORD ----------\nexport function bellmanFord(graph, start, end) {\n  const nodes = Object.keys(graph);\n  const dist = {};\n  const prev = {};\n  nodes.forEach(n => {\n    dist[n] = Infinity;\n    prev[n] = null;\n  });\n  dist[start] = 0;\n  for (let i = 0; i < nodes.length - 1; i++) {\n    for (let u of nodes) {\n      for (let v in graph[u]) {\n        const weight = graph[u][v];\n        if (dist[u] + weight < dist[v]) {\n          dist[v] = dist[u] + weight;\n          prev[v] = u;\n        }\n      }\n    }\n  }\n  const path = [];\n  let u = end;\n  while (u) {\n    path.unshift(u);\n    u = prev[u];\n  }\n  if (dist[end] === Infinity) return {\n    path: [],\n    distance: Infinity\n  };\n  return {\n    path,\n    distance: dist[end]\n  };\n}\n\n// ---------- FLOYD–WARSHALL ----------\nexport function floydWarshall(graph, start, end) {\n  const nodes = Object.keys(graph);\n  const dist = {};\n  const next = {};\n  for (let i of nodes) {\n    dist[i] = {};\n    next[i] = {};\n    for (let j of nodes) {\n      if (i === j) dist[i][j] = 0;else if (graph[i][j] !== undefined) dist[i][j] = graph[i][j];else dist[i][j] = Infinity;\n      next[i][j] = graph[i][j] !== undefined ? j : null;\n    }\n  }\n  for (let k of nodes) {\n    for (let i of nodes) {\n      for (let j of nodes) {\n        if (dist[i][k] + dist[k][j] < dist[i][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n          next[i][j] = next[i][k];\n        }\n      }\n    }\n  }\n  if (next[start][end] === null) return {\n    path: [],\n    distance: Infinity\n  };\n  const path = [];\n  let u = start;\n  while (u !== end) {\n    path.push(u);\n    u = next[u][end];\n  }\n  path.push(end);\n  return {\n    path,\n    distance: dist[start][end]\n  };\n}\n\n// ---------- A* (A-STAR) ----------\nexport function aStar(graph, start, end, coords) {\n  const openSet = new Set([start]);\n  const cameFrom = {};\n  const gScore = {};\n  const fScore = {};\n  for (let node in graph) {\n    gScore[node] = Infinity;\n    fScore[node] = Infinity;\n  }\n  gScore[start] = 0;\n  fScore[start] = heuristic(start, end, coords);\n  while (openSet.size > 0) {\n    let current = null;\n    let minF = Infinity;\n    for (let node of openSet) {\n      if (fScore[node] < minF) {\n        minF = fScore[node];\n        current = node;\n      }\n    }\n    if (current === end) {\n      const path = [];\n      let temp = current;\n      while (temp) {\n        path.unshift(temp);\n        temp = cameFrom[temp];\n      }\n      return {\n        path,\n        distance: gScore[end]\n      };\n    }\n    openSet.delete(current);\n    for (let neighbor in graph[current]) {\n      const tentativeG = gScore[current] + graph[current][neighbor];\n      if (tentativeG < gScore[neighbor]) {\n        cameFrom[neighbor] = current;\n        gScore[neighbor] = tentativeG;\n        fScore[neighbor] = tentativeG + heuristic(neighbor, end, coords);\n        openSet.add(neighbor);\n      }\n    }\n  }\n  return {\n    path: [],\n    distance: Infinity\n  };\n}\nfunction heuristic(a, b, coords) {\n  const dx = coords[a].x - coords[b].x;\n  const dy = coords[a].y - coords[b].y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n// ---------- JOHNSON’S ALGORITHM ----------\nexport function johnson(graph, start, end) {\n  const nodes = Object.keys(graph);\n\n  // Step 1: Add a fake node Q\n  const qGraph = JSON.parse(JSON.stringify(graph));\n  qGraph.Q = {};\n  for (let node of nodes) qGraph.Q[node] = 0;\n\n  // Step 2: Bellman-Ford from Q to all nodes\n  const h = {};\n  const bfResult = bellmanFord(qGraph, \"Q\", null);\n  nodes.forEach(node => {\n    h[node] = 0; // simplified, works since no negative weights\n  });\n\n  // Step 3: Reweight edges\n  const reweighted = {};\n  for (let u of nodes) {\n    reweighted[u] = {};\n    for (let v in graph[u]) {\n      reweighted[u][v] = graph[u][v] + h[u] - h[v];\n    }\n  }\n\n  // Step 4: Dijkstra on reweighted graph\n  return dijkstra(reweighted, start, end);\n}","map":{"version":3,"names":["dijkstra","graph","start","end","dist","prev","visited","Set","node","Infinity","size","Object","keys","length","current","filter","n","has","reduce","a","b","add","neighbor","newDist","path","u","unshift","distance","bellmanFord","nodes","forEach","i","v","weight","floydWarshall","next","j","undefined","k","push","aStar","coords","openSet","cameFrom","gScore","fScore","heuristic","minF","temp","delete","tentativeG","dx","x","dy","y","Math","sqrt","johnson","qGraph","JSON","parse","stringify","Q","h","bfResult","reweighted"],"sources":["/Users/piyushbaghel/Desktop/project/airplane-route-optimizer/src/algorithms.js"],"sourcesContent":["// // algorithms.js\n// // ====================================================\n// // This file defines: Dijkstra, Bellman–Ford, Floyd–Warshall,\n// // A* (A-Star), and Johnson’s Algorithm.\n// // All return { path, distance } for easy visualization.\n// // ====================================================\n\n// // ---------- DIJKSTRA ----------\n// export function dijkstra(graph, start, end) {\n//   const dist = {};\n//   const prev = {};\n//   const visited = new Set();\n\n//   for (let node in graph) {\n//     dist[node] = Infinity;\n//     prev[node] = null;\n//   }\n//   dist[start] = 0;\n\n//   while (visited.size < Object.keys(graph).length) {\n//     const current = Object.keys(graph)\n//       .filter((n) => !visited.has(n))\n//       .reduce((a, b) => (dist[a] < dist[b] ? a : b));\n//     if (dist[current] === Infinity) break;\n//     visited.add(current);\n\n//     for (let neighbor in graph[current]) {\n//       const newDist = dist[current] + graph[current][neighbor];\n//       if (newDist < dist[neighbor]) {\n//         dist[neighbor] = newDist;\n//         prev[neighbor] = current;\n//       }\n//     }\n//   }\n\n//   const path = [];\n//   let u = end;\n//   while (u) {\n//     path.unshift(u);\n//     u = prev[u];\n//   }\n//   return { path, distance: dist[end] };\n// }\n\n// // ---------- BELLMAN–FORD ----------\n// export function bellmanFord(graph, start, end) {\n//   const nodes = Object.keys(graph);\n//   const dist = {};\n//   const prev = {};\n//   nodes.forEach((n) => {\n//     dist[n] = Infinity;\n//     prev[n] = null;\n//   });\n//   dist[start] = 0;\n\n//   for (let i = 0; i < nodes.length - 1; i++) {\n//     for (let u of nodes) {\n//       for (let v in graph[u]) {\n//         const weight = graph[u][v];\n//         if (dist[u] + weight < dist[v]) {\n//           dist[v] = dist[u] + weight;\n//           prev[v] = u;\n//         }\n//       }\n//     }\n//   }\n\n//   const path = [];\n//   let u = end;\n//   while (u) {\n//     path.unshift(u);\n//     u = prev[u];\n//   }\n//   return { path, distance: dist[end] };\n// }\n\n// // ---------- FLOYD–WARSHALL ----------\n// export function floydWarshall(graph, start, end) {\n//   const nodes = Object.keys(graph);\n//   const dist = {};\n//   const next = {};\n\n//   for (let i of nodes) {\n//     dist[i] = {};\n//     next[i] = {};\n//     for (let j of nodes) {\n//       if (i === j) dist[i][j] = 0;\n//       else if (graph[i][j] !== undefined) dist[i][j] = graph[i][j];\n//       else dist[i][j] = Infinity;\n//       if (graph[i][j] !== undefined) next[i][j] = j;\n//       else next[i][j] = null;\n//     }\n//   }\n\n//   for (let k of nodes) {\n//     for (let i of nodes) {\n//       for (let j of nodes) {\n//         if (dist[i][k] + dist[k][j] < dist[i][j]) {\n//           dist[i][j] = dist[i][k] + dist[k][j];\n//           next[i][j] = next[i][k];\n//         }\n//       }\n//     }\n//   }\n\n//   if (next[start][end] === null) return { path: [], distance: Infinity };\n\n//   const path = [];\n//   let u = start;\n//   while (u !== end) {\n//     path.push(u);\n//     u = next[u][end];\n//   }\n//   path.push(end);\n//   return { path, distance: dist[start][end] };\n// }\n\n// // ---------- A* (A-STAR) ----------\n// export function aStar(graph, start, end, coords) {\n//   const open = new Set([start]);\n//   const cameFrom = {};\n//   const gScore = {};\n//   const fScore = {};\n\n//   for (let node in graph) {\n//     gScore[node] = Infinity;\n//     fScore[node] = Infinity;\n//   }\n//   gScore[start] = 0;\n//   fScore[start] = heuristic(start, end, coords);\n\n//   while (open.size > 0) {\n//     let current = null;\n//     let bestF = Infinity;\n//     for (let n of open) {\n//       if (fScore[n] < bestF) {\n//         bestF = fScore[n];\n//         current = n;\n//       }\n//     }\n\n//     if (current === end) {\n//       const path = [];\n//       let c = current;\n//       while (c) {\n//         path.unshift(c);\n//         c = cameFrom[c];\n//       }\n//       return { path, distance: gScore[end] };\n//     }\n\n//     open.delete(current);\n//     for (let neighbor in graph[current]) {\n//       const tentative = gScore[current] + graph[current][neighbor];\n//       if (tentative < gScore[neighbor]) {\n//         cameFrom[neighbor] = current;\n//         gScore[neighbor] = tentative;\n//         fScore[neighbor] = tentative + heuristic(neighbor, end, coords);\n//         open.add(neighbor);\n//       }\n//     }\n//   }\n\n//   return { path: [], distance: Infinity };\n// }\n\n// function heuristic(a, b, coords) {\n//   const dx = coords[a].x - coords[b].x;\n//   const dy = coords[a].y - coords[b].y;\n//   return Math.sqrt(dx * dx + dy * dy);\n// }\n\n// // ---------- JOHNSON’S ALGORITHM ----------\n// export function johnson(graph, start, end) {\n//   const nodes = Object.keys(graph);\n\n//   // Step 1: Add fake node Q\n//   const qGraph = JSON.parse(JSON.stringify(graph));\n//   qGraph.Q = {};\n//   for (let node of nodes) qGraph.Q[node] = 0;\n\n//   // Step 2: Bellman–Ford from Q to get potential h()\n//   const h = {};\n//   const bfResult = bellmanFord(qGraph, \"Q\", null);\n//   nodes.forEach((node) => {\n//     h[node] = bfResult.distance[node]; // correct potential\n//     });\n\n\n//   // Step 3: Reweight edges\n//   const reweighted = {};\n//   for (let u of nodes) {\n//     reweighted[u] = {};\n//     for (let v in graph[u]) {\n//       reweighted[u][v] = graph[u][v] + h[u] - h[v];\n//     }\n//   }\n\n//   // Step 4: Use Dijkstra on reweighted graph\n//   return dijkstra(reweighted, start, end);\n// }\n\n// algorithms.js\n// ====================================================\n// Corrected algorithms: Dijkstra, Bellman–Ford, Floyd–Warshall,\n// A* (A-Star), and Johnson’s Algorithm.\n// All return { path, distance } for visualization\n// ====================================================\n\n// ---------- DIJKSTRA ----------\nexport function dijkstra(graph, start, end) {\n  const dist = {};\n  const prev = {};\n  const visited = new Set();\n\n  for (let node in graph) {\n    dist[node] = Infinity;\n    prev[node] = null;\n  }\n  dist[start] = 0;\n\n  while (visited.size < Object.keys(graph).length) {\n    const current = Object.keys(graph)\n      .filter((n) => !visited.has(n))\n      .reduce((a, b) => (dist[a] < dist[b] ? a : b));\n    if (dist[current] === Infinity) break;\n    visited.add(current);\n\n    for (let neighbor in graph[current]) {\n      const newDist = dist[current] + graph[current][neighbor];\n      if (newDist < dist[neighbor]) {\n        dist[neighbor] = newDist;\n        prev[neighbor] = current;\n      }\n    }\n  }\n\n  const path = [];\n  let u = end;\n  while (u) {\n    path.unshift(u);\n    u = prev[u];\n  }\n\n  if (dist[end] === Infinity) return { path: [], distance: Infinity };\n  return { path, distance: dist[end] };\n}\n\n// ---------- BELLMAN–FORD ----------\nexport function bellmanFord(graph, start, end) {\n  const nodes = Object.keys(graph);\n  const dist = {};\n  const prev = {};\n  nodes.forEach((n) => {\n    dist[n] = Infinity;\n    prev[n] = null;\n  });\n  dist[start] = 0;\n\n  for (let i = 0; i < nodes.length - 1; i++) {\n    for (let u of nodes) {\n      for (let v in graph[u]) {\n        const weight = graph[u][v];\n        if (dist[u] + weight < dist[v]) {\n          dist[v] = dist[u] + weight;\n          prev[v] = u;\n        }\n      }\n    }\n  }\n\n  const path = [];\n  let u = end;\n  while (u) {\n    path.unshift(u);\n    u = prev[u];\n  }\n\n  if (dist[end] === Infinity) return { path: [], distance: Infinity };\n  return { path, distance: dist[end] };\n}\n\n// ---------- FLOYD–WARSHALL ----------\nexport function floydWarshall(graph, start, end) {\n  const nodes = Object.keys(graph);\n  const dist = {};\n  const next = {};\n\n  for (let i of nodes) {\n    dist[i] = {};\n    next[i] = {};\n    for (let j of nodes) {\n      if (i === j) dist[i][j] = 0;\n      else if (graph[i][j] !== undefined) dist[i][j] = graph[i][j];\n      else dist[i][j] = Infinity;\n\n      next[i][j] = graph[i][j] !== undefined ? j : null;\n    }\n  }\n\n  for (let k of nodes) {\n    for (let i of nodes) {\n      for (let j of nodes) {\n        if (dist[i][k] + dist[k][j] < dist[i][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n          next[i][j] = next[i][k];\n        }\n      }\n    }\n  }\n\n  if (next[start][end] === null) return { path: [], distance: Infinity };\n\n  const path = [];\n  let u = start;\n  while (u !== end) {\n    path.push(u);\n    u = next[u][end];\n  }\n  path.push(end);\n\n  return { path, distance: dist[start][end] };\n}\n\n// ---------- A* (A-STAR) ----------\nexport function aStar(graph, start, end, coords) {\n  const openSet = new Set([start]);\n  const cameFrom = {};\n  const gScore = {};\n  const fScore = {};\n\n  for (let node in graph) {\n    gScore[node] = Infinity;\n    fScore[node] = Infinity;\n  }\n\n  gScore[start] = 0;\n  fScore[start] = heuristic(start, end, coords);\n\n  while (openSet.size > 0) {\n    let current = null;\n    let minF = Infinity;\n\n    for (let node of openSet) {\n      if (fScore[node] < minF) {\n        minF = fScore[node];\n        current = node;\n      }\n    }\n\n    if (current === end) {\n      const path = [];\n      let temp = current;\n      while (temp) {\n        path.unshift(temp);\n        temp = cameFrom[temp];\n      }\n      return { path, distance: gScore[end] };\n    }\n\n    openSet.delete(current);\n\n    for (let neighbor in graph[current]) {\n      const tentativeG = gScore[current] + graph[current][neighbor];\n      if (tentativeG < gScore[neighbor]) {\n        cameFrom[neighbor] = current;\n        gScore[neighbor] = tentativeG;\n        fScore[neighbor] = tentativeG + heuristic(neighbor, end, coords);\n        openSet.add(neighbor);\n      }\n    }\n  }\n\n  return { path: [], distance: Infinity };\n}\n\nfunction heuristic(a, b, coords) {\n  const dx = coords[a].x - coords[b].x;\n  const dy = coords[a].y - coords[b].y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n// ---------- JOHNSON’S ALGORITHM ----------\nexport function johnson(graph, start, end) {\n  const nodes = Object.keys(graph);\n\n  // Step 1: Add a fake node Q\n  const qGraph = JSON.parse(JSON.stringify(graph));\n  qGraph.Q = {};\n  for (let node of nodes) qGraph.Q[node] = 0;\n\n  // Step 2: Bellman-Ford from Q to all nodes\n  const h = {};\n  const bfResult = bellmanFord(qGraph, \"Q\", null);\n  nodes.forEach((node) => {\n    h[node] = 0; // simplified, works since no negative weights\n  });\n\n  // Step 3: Reweight edges\n  const reweighted = {};\n  for (let u of nodes) {\n    reweighted[u] = {};\n    for (let v in graph[u]) {\n      reweighted[u][v] = graph[u][v] + h[u] - h[v];\n    }\n  }\n\n  // Step 4: Dijkstra on reweighted graph\n  return dijkstra(reweighted, start, end);\n}\n\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO,SAASA,QAAQA,CAACC,KAAK,EAAEC,KAAK,EAAEC,GAAG,EAAE;EAC1C,MAAMC,IAAI,GAAG,CAAC,CAAC;EACf,MAAMC,IAAI,GAAG,CAAC,CAAC;EACf,MAAMC,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;EAEzB,KAAK,IAAIC,IAAI,IAAIP,KAAK,EAAE;IACtBG,IAAI,CAACI,IAAI,CAAC,GAAGC,QAAQ;IACrBJ,IAAI,CAACG,IAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}