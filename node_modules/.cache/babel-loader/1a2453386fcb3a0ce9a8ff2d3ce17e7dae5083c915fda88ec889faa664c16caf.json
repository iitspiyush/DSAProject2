{"ast":null,"code":"// ===============================================\n// algorithms.js — Flight Route Optimization Algorithms\n// ===============================================\n\n// ✅ DIJKSTRA\nexport function dijkstra(graph, start, end) {\n  const distances = {};\n  const visited = {};\n  const previous = {};\n  for (let node in graph) {\n    distances[node] = Infinity;\n    previous[node] = null;\n  }\n  distances[start] = 0;\n  while (true) {\n    let closest = null;\n    for (let node in graph) {\n      if (!visited[node] && (closest === null || distances[node] < distances[closest])) {\n        closest = node;\n      }\n    }\n    if (closest === null || closest === end) break;\n    visited[closest] = true;\n    for (let neighbor in graph[closest]) {\n      const newDist = distances[closest] + graph[closest][neighbor];\n      if (newDist < distances[neighbor]) {\n        distances[neighbor] = newDist;\n        previous[neighbor] = closest;\n      }\n    }\n  }\n  const path = [];\n  let curr = end;\n  while (curr) {\n    path.unshift(curr);\n    curr = previous[curr];\n  }\n  return {\n    path,\n    distance: distances[end]\n  };\n}\n\n// ✅ BELLMAN-FORD\nexport function bellmanFord(graph, start, end) {\n  const distances = {};\n  const previous = {};\n  for (let node in graph) {\n    distances[node] = Infinity;\n    previous[node] = null;\n  }\n  distances[start] = 0;\n  const edges = [];\n  for (let u in graph) {\n    for (let v in graph[u]) {\n      edges.push([u, v, graph[u][v]]);\n    }\n  }\n  const nodes = Object.keys(graph);\n  for (let i = 0; i < nodes.length - 1; i++) {\n    for (let [u, v, w] of edges) {\n      if (distances[u] + w < distances[v]) {\n        distances[v] = distances[u] + w;\n        previous[v] = u;\n      }\n    }\n  }\n  const path = [];\n  let curr = end;\n  while (curr) {\n    path.unshift(curr);\n    curr = previous[curr];\n  }\n  return {\n    path,\n    distance: distances[end]\n  };\n}\n\n// ✅ FLOYD-WARSHALL\nexport function floydWarshall(graph, start, end) {\n  const nodes = Object.keys(graph);\n  const dist = {};\n  const next = {};\n  for (let i of nodes) {\n    dist[i] = {};\n    next[i] = {};\n    for (let j of nodes) {\n      if (i === j) dist[i][j] = 0;else if (graph[i][j]) dist[i][j] = graph[i][j];else dist[i][j] = Infinity;\n      if (graph[i][j]) next[i][j] = j;\n    }\n  }\n  for (let k of nodes) {\n    for (let i of nodes) {\n      for (let j of nodes) {\n        if (dist[i][k] + dist[k][j] < dist[i][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n          next[i][j] = next[i][k];\n        }\n      }\n    }\n  }\n  const reconstructPath = (u, v) => {\n    if (!next[u][v]) return [];\n    const path = [u];\n    while (u !== v) {\n      u = next[u][v];\n      path.push(u);\n    }\n    return path;\n  };\n  return {\n    path: reconstructPath(start, end),\n    distance: dist[start][end]\n  };\n}\n\n// ✅ JOHNSON’S ALGORITHM (using Bellman-Ford + Dijkstra)\nexport function johnson(graph, start, end) {\n  const nodes = Object.keys(graph);\n  const newGraph = {\n    ...graph,\n    Q: {}\n  };\n  for (let node of nodes) newGraph.Q[node] = 0;\n\n  // Bellman-Ford to find h values\n  const h = {};\n  for (let node in newGraph) h[node] = Infinity;\n  h.Q = 0;\n  const edges = [];\n  for (let u in newGraph) {\n    for (let v in newGraph[u]) {\n      edges.push([u, v, newGraph[u][v]]);\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    for (let [u, v, w] of edges) {\n      if (h[u] + w < h[v]) h[v] = h[u] + w;\n    }\n  }\n\n  // Reweight edges\n  const reweighted = {};\n  for (let u in graph) {\n    reweighted[u] = {};\n    for (let v in graph[u]) {\n      reweighted[u][v] = graph[u][v] + h[u] - h[v];\n    }\n  }\n\n  // Run Dijkstra on reweighted graph\n  return dijkstra(reweighted, start, end);\n}\n\n// ✅ A* ALGORITHM\nexport function aStar(graph, start, end, heuristic = {}) {\n  const openSet = new Set([start]);\n  const cameFrom = {};\n  const gScore = {};\n  const fScore = {};\n  for (let node in graph) {\n    gScore[node] = Infinity;\n    fScore[node] = Infinity;\n  }\n  gScore[start] = 0;\n  fScore[start] = heuristic[start] || 0;\n  while (openSet.size > 0) {\n    let current = [...openSet].reduce((a, b) => fScore[a] < fScore[b] ? a : b);\n    if (current === end) {\n      const path = [];\n      while (current) {\n        path.unshift(current);\n        current = cameFrom[current];\n      }\n      return {\n        path,\n        distance: gScore[end]\n      };\n    }\n    openSet.delete(current);\n    for (let neighbor in graph[current]) {\n      const tentative_g = gScore[current] + graph[current][neighbor];\n      if (tentative_g < gScore[neighbor]) {\n        cameFrom[neighbor] = current;\n        gScore[neighbor] = tentative_g;\n        fScore[neighbor] = tentative_g + (heuristic[neighbor] || 0);\n        openSet.add(neighbor);\n      }\n    }\n  }\n  return {\n    path: [],\n    distance: Infinity\n  };\n}","map":{"version":3,"names":["dijkstra","graph","start","end","distances","visited","previous","node","Infinity","closest","neighbor","newDist","path","curr","unshift","distance","bellmanFord","edges","u","v","push","nodes","Object","keys","i","length","w","floydWarshall","dist","next","j","k","reconstructPath","johnson","newGraph","Q","h","reweighted","aStar","heuristic","openSet","Set","cameFrom","gScore","fScore","size","current","reduce","a","b","delete","tentative_g","add"],"sources":["/Users/piyushbaghel/Desktop/project/airplane-route-optimizer/src/algorithms.js"],"sourcesContent":["// ===============================================\n// algorithms.js — Flight Route Optimization Algorithms\n// ===============================================\n\n// ✅ DIJKSTRA\nexport function dijkstra(graph, start, end) {\n  const distances = {};\n  const visited = {};\n  const previous = {};\n\n  for (let node in graph) {\n    distances[node] = Infinity;\n    previous[node] = null;\n  }\n  distances[start] = 0;\n\n  while (true) {\n    let closest = null;\n    for (let node in graph) {\n      if (!visited[node] && (closest === null || distances[node] < distances[closest])) {\n        closest = node;\n      }\n    }\n    if (closest === null || closest === end) break;\n\n    visited[closest] = true;\n\n    for (let neighbor in graph[closest]) {\n      const newDist = distances[closest] + graph[closest][neighbor];\n      if (newDist < distances[neighbor]) {\n        distances[neighbor] = newDist;\n        previous[neighbor] = closest;\n      }\n    }\n  }\n\n  const path = [];\n  let curr = end;\n  while (curr) {\n    path.unshift(curr);\n    curr = previous[curr];\n  }\n\n  return { path, distance: distances[end] };\n}\n\n// ✅ BELLMAN-FORD\nexport function bellmanFord(graph, start, end) {\n  const distances = {};\n  const previous = {};\n\n  for (let node in graph) {\n    distances[node] = Infinity;\n    previous[node] = null;\n  }\n  distances[start] = 0;\n\n  const edges = [];\n  for (let u in graph) {\n    for (let v in graph[u]) {\n      edges.push([u, v, graph[u][v]]);\n    }\n  }\n\n  const nodes = Object.keys(graph);\n  for (let i = 0; i < nodes.length - 1; i++) {\n    for (let [u, v, w] of edges) {\n      if (distances[u] + w < distances[v]) {\n        distances[v] = distances[u] + w;\n        previous[v] = u;\n      }\n    }\n  }\n\n  const path = [];\n  let curr = end;\n  while (curr) {\n    path.unshift(curr);\n    curr = previous[curr];\n  }\n\n  return { path, distance: distances[end] };\n}\n\n// ✅ FLOYD-WARSHALL\nexport function floydWarshall(graph, start, end) {\n  const nodes = Object.keys(graph);\n  const dist = {};\n  const next = {};\n\n  for (let i of nodes) {\n    dist[i] = {};\n    next[i] = {};\n    for (let j of nodes) {\n      if (i === j) dist[i][j] = 0;\n      else if (graph[i][j]) dist[i][j] = graph[i][j];\n      else dist[i][j] = Infinity;\n      if (graph[i][j]) next[i][j] = j;\n    }\n  }\n\n  for (let k of nodes) {\n    for (let i of nodes) {\n      for (let j of nodes) {\n        if (dist[i][k] + dist[k][j] < dist[i][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n          next[i][j] = next[i][k];\n        }\n      }\n    }\n  }\n\n  const reconstructPath = (u, v) => {\n    if (!next[u][v]) return [];\n    const path = [u];\n    while (u !== v) {\n      u = next[u][v];\n      path.push(u);\n    }\n    return path;\n  };\n\n  return { path: reconstructPath(start, end), distance: dist[start][end] };\n}\n\n// ✅ JOHNSON’S ALGORITHM (using Bellman-Ford + Dijkstra)\nexport function johnson(graph, start, end) {\n  const nodes = Object.keys(graph);\n  const newGraph = { ...graph, Q: {} };\n\n  for (let node of nodes) newGraph.Q[node] = 0;\n\n  // Bellman-Ford to find h values\n  const h = {};\n  for (let node in newGraph) h[node] = Infinity;\n  h.Q = 0;\n\n  const edges = [];\n  for (let u in newGraph) {\n    for (let v in newGraph[u]) {\n      edges.push([u, v, newGraph[u][v]]);\n    }\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    for (let [u, v, w] of edges) {\n      if (h[u] + w < h[v]) h[v] = h[u] + w;\n    }\n  }\n\n  // Reweight edges\n  const reweighted = {};\n  for (let u in graph) {\n    reweighted[u] = {};\n    for (let v in graph[u]) {\n      reweighted[u][v] = graph[u][v] + h[u] - h[v];\n    }\n  }\n\n  // Run Dijkstra on reweighted graph\n  return dijkstra(reweighted, start, end);\n}\n\n// ✅ A* ALGORITHM\nexport function aStar(graph, start, end, heuristic = {}) {\n  const openSet = new Set([start]);\n  const cameFrom = {};\n  const gScore = {};\n  const fScore = {};\n\n  for (let node in graph) {\n    gScore[node] = Infinity;\n    fScore[node] = Infinity;\n  }\n  gScore[start] = 0;\n  fScore[start] = heuristic[start] || 0;\n\n  while (openSet.size > 0) {\n    let current = [...openSet].reduce((a, b) =>\n      fScore[a] < fScore[b] ? a : b\n    );\n\n    if (current === end) {\n      const path = [];\n      while (current) {\n        path.unshift(current);\n        current = cameFrom[current];\n      }\n      return { path, distance: gScore[end] };\n    }\n\n    openSet.delete(current);\n\n    for (let neighbor in graph[current]) {\n      const tentative_g = gScore[current] + graph[current][neighbor];\n      if (tentative_g < gScore[neighbor]) {\n        cameFrom[neighbor] = current;\n        gScore[neighbor] = tentative_g;\n        fScore[neighbor] = tentative_g + (heuristic[neighbor] || 0);\n        openSet.add(neighbor);\n      }\n    }\n  }\n\n  return { path: [], distance: Infinity };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}