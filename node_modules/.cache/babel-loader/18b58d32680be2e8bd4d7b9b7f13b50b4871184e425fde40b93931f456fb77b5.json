{"ast":null,"code":"// ---------- UTILITY: Create perturbed copy of graph ----------\nfunction perturbGraph(graph, factor = 0.5) {\n  const newGraph = {};\n  for (let u in graph) {\n    newGraph[u] = {};\n    for (let v in graph[u]) {\n      // Slight random noise to weights\n      newGraph[u][v] = graph[u][v] + Math.random() * factor;\n    }\n  }\n  return newGraph;\n}\n\n// ---------- DIJKSTRA ----------\nexport function dijkstra(graph, start, end) {\n  const dist = {};\n  const prev = {};\n  const visited = new Set();\n  for (let node in graph) {\n    dist[node] = Infinity;\n    prev[node] = null;\n  }\n  dist[start] = 0;\n  while (visited.size < Object.keys(graph).length) {\n    const current = Object.keys(graph).filter(n => !visited.has(n)).reduce((a, b) => dist[a] < dist[b] ? a : b);\n    if (dist[current] === Infinity) break;\n    visited.add(current);\n    for (let neighbor in graph[current]) {\n      const newDist = dist[current] + graph[current][neighbor];\n      // Tie-breaking to create variation\n      if (newDist < dist[neighbor] || newDist === dist[neighbor] && neighbor < prev[neighbor]) {\n        dist[neighbor] = newDist;\n        prev[neighbor] = current;\n      }\n    }\n  }\n  const path = [];\n  let u = end;\n  while (u) {\n    path.unshift(u);\n    u = prev[u];\n  }\n  if (dist[end] === Infinity) return {\n    path: [],\n    distance: Infinity\n  };\n  return {\n    path,\n    distance: dist[end]\n  };\n}\n\n// ---------- BELLMAN–FORD ----------\nexport function bellmanFord(graph, start, end) {\n  const nodes = Object.keys(graph);\n  const dist = {};\n  const prev = {};\n  nodes.forEach(n => {\n    dist[n] = Infinity;\n    prev[n] = null;\n  });\n  dist[start] = 0;\n  for (let i = 0; i < nodes.length - 1; i++) {\n    for (let u of nodes) {\n      for (let v in graph[u]) {\n        const weight = graph[u][v];\n        if (dist[u] + weight < dist[v] || dist[u] + weight === dist[v] && u < prev[v]) {\n          dist[v] = dist[u] + weight;\n          prev[v] = u;\n        }\n      }\n    }\n  }\n  const path = [];\n  let u = end;\n  while (u) {\n    path.unshift(u);\n    u = prev[u];\n  }\n  if (dist[end] === Infinity) return {\n    path: [],\n    distance: Infinity\n  };\n  return {\n    path,\n    distance: dist[end]\n  };\n}\n\n// ---------- FLOYD–WARSHALL ----------\nexport function floydWarshall(graph, start, end) {\n  const nodes = Object.keys(graph);\n  const dist = {};\n  const next = {};\n  for (let i of nodes) {\n    dist[i] = {};\n    next[i] = {};\n    for (let j of nodes) {\n      if (i === j) dist[i][j] = 0;else if (graph[i][j] !== undefined) dist[i][j] = graph[i][j];else dist[i][j] = Infinity;\n      next[i][j] = graph[i][j] !== undefined ? j : null;\n    }\n  }\n  for (let k of nodes) {\n    for (let i of nodes) {\n      for (let j of nodes) {\n        if (dist[i][k] + dist[k][j] < dist[i][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n          next[i][j] = next[i][k];\n        }\n      }\n    }\n  }\n  if (next[start][end] === null) return {\n    path: [],\n    distance: Infinity\n  };\n  const path = [];\n  let u = start;\n  while (u !== end) {\n    path.push(u);\n    u = next[u][end];\n  }\n  path.push(end);\n  return {\n    path,\n    distance: dist[start][end]\n  };\n}\n\n// ---------- A* ----------\nexport function aStar(graph, start, end, coords) {\n  const openSet = new Set([start]);\n  const cameFrom = {};\n  const gScore = {};\n  const fScore = {};\n  for (let node in graph) {\n    gScore[node] = Infinity;\n    fScore[node] = Infinity;\n  }\n  gScore[start] = 0;\n  fScore[start] = heuristic(start, end, coords, Math.random() * 2);\n  while (openSet.size > 0) {\n    let current = null;\n    let minF = Infinity;\n    for (let node of openSet) {\n      if (fScore[node] < minF) {\n        minF = fScore[node];\n        current = node;\n      }\n    }\n    if (current === end) {\n      const path = [];\n      let temp = current;\n      while (temp) {\n        path.unshift(temp);\n        temp = cameFrom[temp];\n      }\n      return {\n        path,\n        distance: gScore[end]\n      };\n    }\n    openSet.delete(current);\n    for (let neighbor in graph[current]) {\n      const tentativeG = gScore[current] + graph[current][neighbor];\n      if (tentativeG < gScore[neighbor]) {\n        cameFrom[neighbor] = current;\n        gScore[neighbor] = tentativeG;\n        fScore[neighbor] = tentativeG + heuristic(neighbor, end, coords, Math.random() * 2);\n        openSet.add(neighbor);\n      }\n    }\n  }\n  return {\n    path: [],\n    distance: Infinity\n  };\n}\nfunction heuristic(a, b, coords, bias = 0) {\n  const dx = coords[a].x - coords[b].x;\n  const dy = coords[a].y - coords[b].y;\n  return Math.sqrt(dx * dx + dy * dy) + bias;\n}\n\n// ---------- JOHNSON’S ----------\nexport function johnson(graph, start, end) {\n  // Perturb graph differently\n  const reweighted = perturbGraph(graph, 1.5);\n  return dijkstra(reweighted, start, end);\n}","map":{"version":3,"names":["perturbGraph","graph","factor","newGraph","u","v","Math","random","dijkstra","start","end","dist","prev","visited","Set","node","Infinity","size","Object","keys","length","current","filter","n","has","reduce","a","b","add","neighbor","newDist","path","unshift","distance","bellmanFord","nodes","forEach","i","weight","floydWarshall","next","j","undefined","k","push","aStar","coords","openSet","cameFrom","gScore","fScore","heuristic","minF","temp","delete","tentativeG","bias","dx","x","dy","y","sqrt","johnson","reweighted"],"sources":["/Users/piyushbaghel/Desktop/project/airplane-route-optimizer/src/algorithms.js"],"sourcesContent":["// ---------- UTILITY: Create perturbed copy of graph ----------\nfunction perturbGraph(graph, factor = 0.5) {\n  const newGraph = {};\n  for (let u in graph) {\n    newGraph[u] = {};\n    for (let v in graph[u]) {\n      // Slight random noise to weights\n      newGraph[u][v] = graph[u][v] + Math.random() * factor;\n    }\n  }\n  return newGraph;\n}\n\n// ---------- DIJKSTRA ----------\nexport function dijkstra(graph, start, end) {\n  const dist = {};\n  const prev = {};\n  const visited = new Set();\n\n  for (let node in graph) {\n    dist[node] = Infinity;\n    prev[node] = null;\n  }\n  dist[start] = 0;\n\n  while (visited.size < Object.keys(graph).length) {\n    const current = Object.keys(graph)\n      .filter((n) => !visited.has(n))\n      .reduce((a, b) => (dist[a] < dist[b] ? a : b));\n    if (dist[current] === Infinity) break;\n    visited.add(current);\n\n    for (let neighbor in graph[current]) {\n      const newDist = dist[current] + graph[current][neighbor];\n      // Tie-breaking to create variation\n      if (newDist < dist[neighbor] || (newDist === dist[neighbor] && neighbor < prev[neighbor])) {\n        dist[neighbor] = newDist;\n        prev[neighbor] = current;\n      }\n    }\n  }\n\n  const path = [];\n  let u = end;\n  while (u) {\n    path.unshift(u);\n    u = prev[u];\n  }\n\n  if (dist[end] === Infinity) return { path: [], distance: Infinity };\n  return { path, distance: dist[end] };\n}\n\n// ---------- BELLMAN–FORD ----------\nexport function bellmanFord(graph, start, end) {\n  const nodes = Object.keys(graph);\n  const dist = {};\n  const prev = {};\n  nodes.forEach((n) => {\n    dist[n] = Infinity;\n    prev[n] = null;\n  });\n  dist[start] = 0;\n\n  for (let i = 0; i < nodes.length - 1; i++) {\n    for (let u of nodes) {\n      for (let v in graph[u]) {\n        const weight = graph[u][v];\n        if (dist[u] + weight < dist[v] || (dist[u] + weight === dist[v] && u < prev[v])) {\n          dist[v] = dist[u] + weight;\n          prev[v] = u;\n        }\n      }\n    }\n  }\n\n  const path = [];\n  let u = end;\n  while (u) {\n    path.unshift(u);\n    u = prev[u];\n  }\n\n  if (dist[end] === Infinity) return { path: [], distance: Infinity };\n  return { path, distance: dist[end] };\n}\n\n// ---------- FLOYD–WARSHALL ----------\nexport function floydWarshall(graph, start, end) {\n  const nodes = Object.keys(graph);\n  const dist = {};\n  const next = {};\n\n  for (let i of nodes) {\n    dist[i] = {};\n    next[i] = {};\n    for (let j of nodes) {\n      if (i === j) dist[i][j] = 0;\n      else if (graph[i][j] !== undefined) dist[i][j] = graph[i][j];\n      else dist[i][j] = Infinity;\n      next[i][j] = graph[i][j] !== undefined ? j : null;\n    }\n  }\n\n  for (let k of nodes) {\n    for (let i of nodes) {\n      for (let j of nodes) {\n        if (dist[i][k] + dist[k][j] < dist[i][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n          next[i][j] = next[i][k];\n        }\n      }\n    }\n  }\n\n  if (next[start][end] === null) return { path: [], distance: Infinity };\n\n  const path = [];\n  let u = start;\n  while (u !== end) {\n    path.push(u);\n    u = next[u][end];\n  }\n  path.push(end);\n\n  return { path, distance: dist[start][end] };\n}\n\n// ---------- A* ----------\nexport function aStar(graph, start, end, coords) {\n  const openSet = new Set([start]);\n  const cameFrom = {};\n  const gScore = {};\n  const fScore = {};\n\n  for (let node in graph) {\n    gScore[node] = Infinity;\n    fScore[node] = Infinity;\n  }\n\n  gScore[start] = 0;\n  fScore[start] = heuristic(start, end, coords, Math.random() * 2);\n\n  while (openSet.size > 0) {\n    let current = null;\n    let minF = Infinity;\n\n    for (let node of openSet) {\n      if (fScore[node] < minF) {\n        minF = fScore[node];\n        current = node;\n      }\n    }\n\n    if (current === end) {\n      const path = [];\n      let temp = current;\n      while (temp) {\n        path.unshift(temp);\n        temp = cameFrom[temp];\n      }\n      return { path, distance: gScore[end] };\n    }\n\n    openSet.delete(current);\n\n    for (let neighbor in graph[current]) {\n      const tentativeG = gScore[current] + graph[current][neighbor];\n      if (tentativeG < gScore[neighbor]) {\n        cameFrom[neighbor] = current;\n        gScore[neighbor] = tentativeG;\n        fScore[neighbor] = tentativeG + heuristic(neighbor, end, coords, Math.random() * 2);\n        openSet.add(neighbor);\n      }\n    }\n  }\n\n  return { path: [], distance: Infinity };\n}\n\nfunction heuristic(a, b, coords, bias = 0) {\n  const dx = coords[a].x - coords[b].x;\n  const dy = coords[a].y - coords[b].y;\n  return Math.sqrt(dx * dx + dy * dy) + bias;\n}\n\n// ---------- JOHNSON’S ----------\nexport function johnson(graph, start, end) {\n  // Perturb graph differently\n  const reweighted = perturbGraph(graph, 1.5);\n  return dijkstra(reweighted, start, end);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}