{"ast":null,"code":"// // algorithms.js\n// // ====================================================\n// // This file defines: Dijkstra, Bellman–Ford, Floyd–Warshall,\n// // A* (A-Star), and Johnson’s Algorithm.\n// // All return { path, distance } for easy visualization.\n// // ====================================================\n\n// // ---------- DIJKSTRA ----------\n// export function dijkstra(graph, start, end) {\n//   const dist = {};\n//   const prev = {};\n//   const visited = new Set();\n\n//   for (let node in graph) {\n//     dist[node] = Infinity;\n//     prev[node] = null;\n//   }\n//   dist[start] = 0;\n\n//   while (visited.size < Object.keys(graph).length) {\n//     const current = Object.keys(graph)\n//       .filter((n) => !visited.has(n))\n//       .reduce((a, b) => (dist[a] < dist[b] ? a : b));\n//     if (dist[current] === Infinity) break;\n//     visited.add(current);\n\n//     for (let neighbor in graph[current]) {\n//       const newDist = dist[current] + graph[current][neighbor];\n//       if (newDist < dist[neighbor]) {\n//         dist[neighbor] = newDist;\n//         prev[neighbor] = current;\n//       }\n//     }\n//   }\n\n//   const path = [];\n//   let u = end;\n//   while (u) {\n//     path.unshift(u);\n//     u = prev[u];\n//   }\n//   return { path, distance: dist[end] };\n// }\n\n// // ---------- BELLMAN–FORD ----------\n// export function bellmanFord(graph, start, end) {\n//   const nodes = Object.keys(graph);\n//   const dist = {};\n//   const prev = {};\n//   nodes.forEach((n) => {\n//     dist[n] = Infinity;\n//     prev[n] = null;\n//   });\n//   dist[start] = 0;\n\n//   for (let i = 0; i < nodes.length - 1; i++) {\n//     for (let u of nodes) {\n//       for (let v in graph[u]) {\n//         const weight = graph[u][v];\n//         if (dist[u] + weight < dist[v]) {\n//           dist[v] = dist[u] + weight;\n//           prev[v] = u;\n//         }\n//       }\n//     }\n//   }\n\n//   const path = [];\n//   let u = end;\n//   while (u) {\n//     path.unshift(u);\n//     u = prev[u];\n//   }\n//   return { path, distance: dist[end] };\n// }\n\n// // ---------- FLOYD–WARSHALL ----------\n// export function floydWarshall(graph, start, end) {\n//   const nodes = Object.keys(graph);\n//   const dist = {};\n//   const next = {};\n\n//   for (let i of nodes) {\n//     dist[i] = {};\n//     next[i] = {};\n//     for (let j of nodes) {\n//       if (i === j) dist[i][j] = 0;\n//       else if (graph[i][j] !== undefined) dist[i][j] = graph[i][j];\n//       else dist[i][j] = Infinity;\n//       if (graph[i][j] !== undefined) next[i][j] = j;\n//       else next[i][j] = null;\n//     }\n//   }\n\n//   for (let k of nodes) {\n//     for (let i of nodes) {\n//       for (let j of nodes) {\n//         if (dist[i][k] + dist[k][j] < dist[i][j]) {\n//           dist[i][j] = dist[i][k] + dist[k][j];\n//           next[i][j] = next[i][k];\n//         }\n//       }\n//     }\n//   }\n\n//   if (next[start][end] === null) return { path: [], distance: Infinity };\n\n//   const path = [];\n//   let u = start;\n//   while (u !== end) {\n//     path.push(u);\n//     u = next[u][end];\n//   }\n//   path.push(end);\n//   return { path, distance: dist[start][end] };\n// }\n\n// // ---------- A* (A-STAR) ----------\n// export function aStar(graph, start, end, coords) {\n//   const open = new Set([start]);\n//   const cameFrom = {};\n//   const gScore = {};\n//   const fScore = {};\n\n//   for (let node in graph) {\n//     gScore[node] = Infinity;\n//     fScore[node] = Infinity;\n//   }\n//   gScore[start] = 0;\n//   fScore[start] = heuristic(start, end, coords);\n\n//   while (open.size > 0) {\n//     let current = null;\n//     let bestF = Infinity;\n//     for (let n of open) {\n//       if (fScore[n] < bestF) {\n//         bestF = fScore[n];\n//         current = n;\n//       }\n//     }\n\n//     if (current === end) {\n//       const path = [];\n//       let c = current;\n//       while (c) {\n//         path.unshift(c);\n//         c = cameFrom[c];\n//       }\n//       return { path, distance: gScore[end] };\n//     }\n\n//     open.delete(current);\n//     for (let neighbor in graph[current]) {\n//       const tentative = gScore[current] + graph[current][neighbor];\n//       if (tentative < gScore[neighbor]) {\n//         cameFrom[neighbor] = current;\n//         gScore[neighbor] = tentative;\n//         fScore[neighbor] = tentative + heuristic(neighbor, end, coords);\n//         open.add(neighbor);\n//       }\n//     }\n//   }\n\n//   return { path: [], distance: Infinity };\n// }\n\n// function heuristic(a, b, coords) {\n//   const dx = coords[a].x - coords[b].x;\n//   const dy = coords[a].y - coords[b].y;\n//   return Math.sqrt(dx * dx + dy * dy);\n// }\n\n// // ---------- JOHNSON’S ALGORITHM ----------\n// export function johnson(graph, start, end) {\n//   const nodes = Object.keys(graph);\n\n//   // Step 1: Add fake node Q\n//   const qGraph = JSON.parse(JSON.stringify(graph));\n//   qGraph.Q = {};\n//   for (let node of nodes) qGraph.Q[node] = 0;\n\n//   // Step 2: Bellman–Ford from Q to get potential h()\n//   const h = {};\n//   const bfResult = bellmanFord(qGraph, \"Q\", null);\n//   nodes.forEach((node) => {\n//     h[node] = bfResult.distance[node]; // correct potential\n//     });\n\n//   // Step 3: Reweight edges\n//   const reweighted = {};\n//   for (let u of nodes) {\n//     reweighted[u] = {};\n//     for (let v in graph[u]) {\n//       reweighted[u][v] = graph[u][v] + h[u] - h[v];\n//     }\n//   }\n\n//   // Step 4: Use Dijkstra on reweighted graph\n//   return dijkstra(reweighted, start, end);\n// }","map":{"version":3,"names":[],"sources":["/Users/piyushbaghel/Desktop/project/airplane-route-optimizer/src/algorithms.js"],"sourcesContent":["// // algorithms.js\n// // ====================================================\n// // This file defines: Dijkstra, Bellman–Ford, Floyd–Warshall,\n// // A* (A-Star), and Johnson’s Algorithm.\n// // All return { path, distance } for easy visualization.\n// // ====================================================\n\n// // ---------- DIJKSTRA ----------\n// export function dijkstra(graph, start, end) {\n//   const dist = {};\n//   const prev = {};\n//   const visited = new Set();\n\n//   for (let node in graph) {\n//     dist[node] = Infinity;\n//     prev[node] = null;\n//   }\n//   dist[start] = 0;\n\n//   while (visited.size < Object.keys(graph).length) {\n//     const current = Object.keys(graph)\n//       .filter((n) => !visited.has(n))\n//       .reduce((a, b) => (dist[a] < dist[b] ? a : b));\n//     if (dist[current] === Infinity) break;\n//     visited.add(current);\n\n//     for (let neighbor in graph[current]) {\n//       const newDist = dist[current] + graph[current][neighbor];\n//       if (newDist < dist[neighbor]) {\n//         dist[neighbor] = newDist;\n//         prev[neighbor] = current;\n//       }\n//     }\n//   }\n\n//   const path = [];\n//   let u = end;\n//   while (u) {\n//     path.unshift(u);\n//     u = prev[u];\n//   }\n//   return { path, distance: dist[end] };\n// }\n\n// // ---------- BELLMAN–FORD ----------\n// export function bellmanFord(graph, start, end) {\n//   const nodes = Object.keys(graph);\n//   const dist = {};\n//   const prev = {};\n//   nodes.forEach((n) => {\n//     dist[n] = Infinity;\n//     prev[n] = null;\n//   });\n//   dist[start] = 0;\n\n//   for (let i = 0; i < nodes.length - 1; i++) {\n//     for (let u of nodes) {\n//       for (let v in graph[u]) {\n//         const weight = graph[u][v];\n//         if (dist[u] + weight < dist[v]) {\n//           dist[v] = dist[u] + weight;\n//           prev[v] = u;\n//         }\n//       }\n//     }\n//   }\n\n//   const path = [];\n//   let u = end;\n//   while (u) {\n//     path.unshift(u);\n//     u = prev[u];\n//   }\n//   return { path, distance: dist[end] };\n// }\n\n// // ---------- FLOYD–WARSHALL ----------\n// export function floydWarshall(graph, start, end) {\n//   const nodes = Object.keys(graph);\n//   const dist = {};\n//   const next = {};\n\n//   for (let i of nodes) {\n//     dist[i] = {};\n//     next[i] = {};\n//     for (let j of nodes) {\n//       if (i === j) dist[i][j] = 0;\n//       else if (graph[i][j] !== undefined) dist[i][j] = graph[i][j];\n//       else dist[i][j] = Infinity;\n//       if (graph[i][j] !== undefined) next[i][j] = j;\n//       else next[i][j] = null;\n//     }\n//   }\n\n//   for (let k of nodes) {\n//     for (let i of nodes) {\n//       for (let j of nodes) {\n//         if (dist[i][k] + dist[k][j] < dist[i][j]) {\n//           dist[i][j] = dist[i][k] + dist[k][j];\n//           next[i][j] = next[i][k];\n//         }\n//       }\n//     }\n//   }\n\n//   if (next[start][end] === null) return { path: [], distance: Infinity };\n\n//   const path = [];\n//   let u = start;\n//   while (u !== end) {\n//     path.push(u);\n//     u = next[u][end];\n//   }\n//   path.push(end);\n//   return { path, distance: dist[start][end] };\n// }\n\n// // ---------- A* (A-STAR) ----------\n// export function aStar(graph, start, end, coords) {\n//   const open = new Set([start]);\n//   const cameFrom = {};\n//   const gScore = {};\n//   const fScore = {};\n\n//   for (let node in graph) {\n//     gScore[node] = Infinity;\n//     fScore[node] = Infinity;\n//   }\n//   gScore[start] = 0;\n//   fScore[start] = heuristic(start, end, coords);\n\n//   while (open.size > 0) {\n//     let current = null;\n//     let bestF = Infinity;\n//     for (let n of open) {\n//       if (fScore[n] < bestF) {\n//         bestF = fScore[n];\n//         current = n;\n//       }\n//     }\n\n//     if (current === end) {\n//       const path = [];\n//       let c = current;\n//       while (c) {\n//         path.unshift(c);\n//         c = cameFrom[c];\n//       }\n//       return { path, distance: gScore[end] };\n//     }\n\n//     open.delete(current);\n//     for (let neighbor in graph[current]) {\n//       const tentative = gScore[current] + graph[current][neighbor];\n//       if (tentative < gScore[neighbor]) {\n//         cameFrom[neighbor] = current;\n//         gScore[neighbor] = tentative;\n//         fScore[neighbor] = tentative + heuristic(neighbor, end, coords);\n//         open.add(neighbor);\n//       }\n//     }\n//   }\n\n//   return { path: [], distance: Infinity };\n// }\n\n// function heuristic(a, b, coords) {\n//   const dx = coords[a].x - coords[b].x;\n//   const dy = coords[a].y - coords[b].y;\n//   return Math.sqrt(dx * dx + dy * dy);\n// }\n\n// // ---------- JOHNSON’S ALGORITHM ----------\n// export function johnson(graph, start, end) {\n//   const nodes = Object.keys(graph);\n\n//   // Step 1: Add fake node Q\n//   const qGraph = JSON.parse(JSON.stringify(graph));\n//   qGraph.Q = {};\n//   for (let node of nodes) qGraph.Q[node] = 0;\n\n//   // Step 2: Bellman–Ford from Q to get potential h()\n//   const h = {};\n//   const bfResult = bellmanFord(qGraph, \"Q\", null);\n//   nodes.forEach((node) => {\n//     h[node] = bfResult.distance[node]; // correct potential\n//     });\n\n\n//   // Step 3: Reweight edges\n//   const reweighted = {};\n//   for (let u of nodes) {\n//     reweighted[u] = {};\n//     for (let v in graph[u]) {\n//       reweighted[u][v] = graph[u][v] + h[u] - h[v];\n//     }\n//   }\n\n//   // Step 4: Use Dijkstra on reweighted graph\n//   return dijkstra(reweighted, start, end);\n// }\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}